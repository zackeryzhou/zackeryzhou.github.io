<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
		<title>Infinity Mirrors</title>
		<style>
			body { margin:0;}
		</style>
        <script src="js/three.js"></script>
        <script src="js/OrbitControls.js"></script>
        <script src="js/lil-gui.js"></script>
        <script src="js/stats.js"></script>
        <script src="js/Reflector.js"></script>
        <script src="js/OBJLoader.js"></script>
	</head>
	<body>
		<script>
            
            /* I. Declare variables */
            var container;
            var scene, camera, renderer;
            var mirrors = [];
            var num_mirrors = 6;
            var options = {
                ambientLight : {
                    'on': true,
                    'intensity': 1,              
                },
                pointLight : {
                    'on': true,
                    'intensity': 1, 
                    'helper': false,
                },
                reflection : {
                    'number': 2,
                    'opacity': 0.7,
                },
                background : {
                    'sky': true,
                }
            };

            /* II. Init container */
            container = document.createElement('div');
            document.body.appendChild(container);
			
            /* III. Init scene */
            scene = new THREE.Scene();

            // (a) Set background
            if (options.background.sky){
                var path = "textures/sky/";
                var format = '.jpg';
                var urls = [
                    path + 'px' + format, path + 'nx' + format,
                    path + 'py' + format, path + 'ny' + format,
                    path + 'pz' + format, path + 'nz' + format
                ];
                var textureCube = new THREE.CubeTextureLoader().load(urls);
                textureCube.format = THREE.RGBFormat;
                scene.background = textureCube;
            }else{
                scene.background = new THREE.Color( 0xa0a0a0 );
            }

            // (b) Set ambient light
            var ambientLight = new THREE.AmbientLight(  0x404040 );
            ambientLight.position.set( 0, 100, 0 );
            ambientLight.name = 'ambientLight'
            scene.add( ambientLight );
            
            // (c) Set point light
            var pointLight = new THREE.PointLight( 0xffffff, 1, 100 );
            pointLight.position.set( 0, 80, 0 );
            pointLight.castShadow = true;
            pointLight.shadow.camera.far = 10;
            pointLight.shadow.camera.fov = 90;
            pointLight.name = 'pointLight';
            scene.add( pointLight );

            var pointLightHelper = new THREE.CameraHelper(pointLight.shadow.camera);
            if (!options.pointLight.helper) {pointLightHelper.visible = false;}
            pointLightHelper.name = 'pointLightHelper';
            scene.add( pointLightHelper )

            // (d) Set road
            var textureLoader = new THREE.TextureLoader();
            var road_texture = textureLoader.load("textures/road/Tileable_cracked_asphalt_road_texture.jpg");
            road_texture.wrapS = road_texture.wrapT = THREE.RepeatWrapping;
            road_texture.repeat.set(1,2);
            road_texture.encoding = THREE.sRGBEncoding;
            var road_bump = textureLoader.load("textures/road/Tileable_cracked_asphalt_road_texture_NORMAL.jpg");
            road_bump.wrapS = road_bump.wrapT = THREE.RepeatWrapping;
            road_bump.repeat.set(1,2);
            var road_roughness = textureLoader.load("textures/road/Tileable_cracked_asphalt_road_texture_SPECULAR.jpg");
            road_roughness.wrapS = road_roughness.wrapT = THREE.RepeatWrapping;
            road_roughness.repeat.set(1,2);

            roadMat = new THREE.MeshStandardMaterial( {
                roughness: 1,
                color: 0xffffff,
                metalness: 0,
                bumpScale: 0.05,
                map: road_texture,
                bumpMap: road_bump,
                roughnessMap: road_roughness,
            } );
            var roadGeometry = new THREE.PlaneGeometry( 100, 200 );
            var roadMesh = new THREE.Mesh( roadGeometry, roadMat );
            roadMesh.rotation.x = - Math.PI / 2.0;
            roadMesh.receiveShadow = true;
            scene.add( roadMesh );

            // (e) Set mirrors

            // configure mirror with opacity option
            var opacity_mirror_material = new THREE.ShaderMaterial({
                uniforms: {
                    tDiffuse: {value: null},
                    textureMatrix: {value: null},
                    // use opacity
                    opacity: {value: options.reflection.opacity},
                },
                vertexShader: 
                    `uniform mat4 textureMatrix;
                    varying vec4 vUv;
                    #include <common>
                    #include <logdepthbuf_pars_vertex>

                    void main() {
                        vUv = textureMatrix * vec4( position, 1.0 );
                        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                        #include <logdepthbuf_vertex>
                    }`,
                fragmentShader: 
                    `uniform sampler2D tDiffuse;
                    // use opacity
                    uniform float opacity; 
                    varying vec4 vUv;
                    #include <logdepthbuf_pars_fragment>

                    void main() {
                        #include <logdepthbuf_fragment>
                        vec4 base = texture2DProj( tDiffuse, vUv );
                        // use opacity
                        gl_FragColor = vec4(  base.rgb, opacity );
                        #include <tonemapping_fragment>
                        #include <encodings_fragment>
                    }`
            });

            // generate mirrors
            var geometry = new THREE.PlaneGeometry( 100, 100 );
            for (var i = 0; i < num_mirrors; i++) {
                var verticalMirror = new THREE.Reflector( geometry, {
                        textureWidth: window.innerWidth * window.devicePixelRatio,
                        textureHeight: window.innerHeight * window.devicePixelRatio,
                        shader: opacity_mirror_material,
                } );
                // to make opacity work
                verticalMirror.material.transparent = true;
                if (i % 2 == 0){
                    verticalMirror.position.set(0,50,-100);
                    
                } else {
                    verticalMirror.rotateY( Math.PI );
                    verticalMirror.position.set(0,50,100);
                }
                verticalMirror.visible = false;
                scene.add(verticalMirror);
                mirrors.push(verticalMirror);
            }
            for (var i = 0; i < num_mirrors; i++){
                if (i < options.reflection.number){
                    mirrors[i].visible = true;
                }else{
                    mirrors[i].visible = false;
                }
            }
            
            // (f) Set bunny
            const objLoader = new THREE.OBJLoader().load(
                'geometry/bunny.obj',  function ( object ) {
                    model = object.children[ 0 ];
                    model.position.set( 0, 30, 0 );
                    model.scale.setScalar( 6 );
                    model.material = new THREE.MeshPhongMaterial();
                    model.castShadow = true;
                    scene.add( model );
                }
            );
                
            /* IV. Init camera */
            camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
            // camera.position.set(50,50,100);
            // camera.position.set(-400,200,0);
            camera.position.set(30,50,100);

            /* V. Init renderer */
            renderer = new THREE.WebGLRenderer();
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild( renderer.domElement );
            
            /* VI. Auxiliary tools */

            // (a) Set FPS display
            stats = new Stats();
            container.appendChild( stats.dom );

            // (b) Enable orbit control
            var controls = new THREE.OrbitControls( camera, renderer.domElement );
            window.addEventListener('resize', function(){
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                }, false);

            // (c) Set control panel
            const panel = new lil.GUI();
            const folder1 = panel.addFolder( 'Ambient light' );
            
            folder1.add(options.ambientLight, 'on').onChange(
                function (e) {
                    scene.getObjectByName('ambientLight').visible = e;
                }
            );
            folder1.add(options.ambientLight, 'intensity', 0, 2 );

            const folder2 = panel.addFolder( 'Point light' );
            folder2.add(options.pointLight, 'on').onChange(
                function (e) {
                    scene.getObjectByName('pointLight').visible = e;
                }
            );
            folder2.add(options.pointLight, 'intensity', 0, 2 );
            // folder2.add(options.pointLight, 'helper').onChange(
            //     function (e) {
            //         scene.getObjectByName('pointLightHelper').visible = e;
            //     }
            // );
            
            const folder3 = panel.addFolder( 'Reflection' );
            folder3.add(options.reflection, 'number', 0, num_mirrors, 1).onChange(
                function(){
                    for (var i = 0; i < num_mirrors; i++){
                        if (i < options.reflection.number){
                            mirrors[i].visible = true;
                        }else{
                            mirrors[i].visible = false;
                        }
                    }
                });
            folder3.add(options.reflection, 'opacity', 0, 1 ).onChange(
                function(){
                    for (var i = 0; i < num_mirrors; i++){
                        mirrors[i].material.uniforms.opacity.value = options.reflection.opacity;
                    }
                }
            );

            const folder4 = panel.addFolder( 'Background' );
            folder4.add(options.background, 'sky').onChange(
                function(e){
                    if (e){
                        var path = "textures/sky/";
                        var format = '.jpg';
                        var urls = [
                            path + 'px' + format, path + 'nx' + format,
                            path + 'py' + format, path + 'ny' + format,
                            path + 'pz' + format, path + 'nz' + format
                        ];
                        var textureCube = new THREE.CubeTextureLoader().load(urls);
                        textureCube.format = THREE.RGBFormat;
                        scene.background = textureCube;
                    }else{
                        scene.background = new THREE.Color( 0xa0a0a0 );
                    }
                }
            );
            
            /* VII. Render */
            function animate() {
                requestAnimationFrame( animate );

                ambientLight.intensity = options.ambientLight.intensity;
                pointLight.intensity = options.pointLight.intensity;

                renderer.render( scene, camera );
                stats.update();
                controls.update();
            };

            animate();

		</script>
	</body>
</html>
